################################################################################
################################################################################
#' ehk21@ic.ac.uk - May 2022
#' 
#' Creates and saves raster of specified landscape with values of fields chosen for optimisation replaced with expOp land cover codes as generated by the nsga2R function. (+ edge feature rasters)
#'
#' @param x vector of shuffled numbers between upper bound and lower bound whih correspond to row values in optim_landcovers data frame (for assigning new landcover during optimisation) 
#' @param optimLandcovers data frame of land covers to be shuffled during optimisation and their respective expOp codes.
#' @param optimFields data frame consisting of current landcover for each field included in the optimisation (and column for new landcover as defined by shuffled values in x)
#' @param optimRaster and...
#' @param otherRaster rasters of landscape separated by fields whose landcover will and won't be shuffled
#' @param optimPixels by-pixel dataframe of landcovers of fields to be optimised
#' @param boundaries vector of boundaries separated by field ID, as generated in prepare landscape function
#' @param otherMargins raster of arable field margins in fixed portion of the landscape, as generated in prepare landscape function
#' @param otherWoodland raster of woodland boundaries in fixed portion of the landscape, as generated in prepare landscape function
#' @param optimPixels by-pixel dataframe of landcover values in landscape raster, as generated in prepare landscape function
#' @param gridSquare vector containing details of specified grid square (used for creating reference raster & calling relevent rasters in fitness function).
#'                  format: c(gridsquare name, xmin, xmax, ymin, ymax)
#'                  
#' @return landcover raster of specified landscape with newly shuffled landcover codes as specified by the optimisation algorithm
#' 
################################################################################
################################################################################

new.landscape <- function(x, optimLandcovers=optimLandcovers, 
                          optimFields=optimFields, optimRaster=optimRaster, 
                          otherRaster=otherRaster, boundaries=boundaries, otherMargins=otherMargins, otherWoodland=otherWoodland, optimPixels=optimPixels, gridSquare=gridSquare){
  
  # Create vector of randomly generated ExpOp codes  
  shuffle <- rep(NA, length(x)) 
  for (i in 1:length(x)){
    row <- x[i]
    shuffle[i] <- optimLandcovers$Code_ExpOp_GFS[row]
  }
  
  # Replace land cover codes of optim fields with shuffled allocations
  optimFields$Code_ExpOp_GFS<- shuffle
  
  # Replace old land cover codes in pixels dataframe with new codes
  optimPixels <- dplyr::left_join(optimPixels, optimFields %>% st_drop_geometry(), by = "gid") 
  optimPixels <- subset(optimPixels, select=c("gid", "Code_ExpOp_GFS.y")) 
  colnames(optimPixels)[2] <- "Code_ExpOp_GFS"
  
  # replace values in optim raster with new codes in pixels dataframe 
  values(optimRaster)<-as.numeric(optimPixels$Code_ExpOp_GFS)
  
  # Combine optim_raster with other_raster so the whole landscape can be run through Poll4pop
  landcoverRaster <- optimRaster
  landcoverRaster[is.na(optimRaster)] <- otherRaster[is.na(landcoverRaster)]

  # Create reference raster for gridsquare
  ref <- raster(xmn=as.numeric(gridSquare[2]), xmx=as.numeric(gridSquare[3]), 
                ymn=as.numeric(gridSquare[4]),ymx= as.numeric(gridSquare[5]), 
                res=c(25,25), crs='+init=EPSG:27700')
  

  # Create grassy field margins raster
  if(length(which((optimFields$Code_ExpOp_GFS %in% c("30","33", "28", "14"))==TRUE))>0){
    arableBoundaries <- boundaries[which(optimFields$Code_ExpOp_GFS %in% c("30","33", "28", "14"))]
    marginsRaster <- landcoverRaster
    values(marginsRaster) <- NA
    for(i in 1:length(arableBoundaries)){
      values(marginsRaster) <- replace(values(marginsRaster), is.na(values(arableBoundaries[[i]]))==FALSE, 1)
    }
    values(marginsRaster)[which(values(otherMargins)==1)] <- values(otherMargins)[which(values(otherMargins)==1)]
  } else {
    marginsRaster<-otherMargins
  }
  
  # Create woodland boundaries raster
  if(length(which((optimFields$Code_ExpOp_GFS %in% c("3","4"))==TRUE))>0){
    woodlandBoundaries <- boundaries[which(optimFields$Code_ExpOp_GFS %in% c("3", "4"))]
    woodlandRaster <- landcoverRaster
    values(woodlandRaster) <- NA
    for(i in 1:length(woodlandBoundaries)){
      values(woodlandRaster) <- replace(values(woodlandRaster), is.na(values(woodlandBoundaries[[i]]))==FALSE, 1)
    }
    values(woodlandRaster)[which(values(otherWoodland)==1)] <- values(otherWoodland)[which(values(otherWoodland)==1)] 
  } else {
    woodlandRaster<-otherWoodland
  }
  
  # return rasters
  return(list("landcoverRaster"=landcoverRaster, "marginsRaster"=marginsRaster, "woodlandRaster"=woodlandRaster))
}